---
layout: post
title: 기술면접 준비 - 운영체제
author: sisipark
tags: [기술면접]
excerpt_separator: <!--more-->
---

# 기술 면접 준비



## 운영 체제
<!--more-->

1. 프로세스와 스레드의 차이
<details>
  <summary>답변보기 ▾</summary>
  <div markdown="1">
    프로세스는 운영체제로부터 자원을 할당받은 작업의 단위이며 스레드는 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위이다.
    프로그램을 실행시키면 운영체제가 프로그램에 독립적인 메모리 공간을 할당해준다. 즉 프로세스는 메모리에 올라간 프로그램 실행 단위이다.
    하나의 프로세스 내에 여러 스레드를 생성 가능하다. 프로세스와 다르게 프로세스 내에서 메모리를 공유해가며 작동이 가능하다.

    프로세스가 메모리에 올라갈 때 운영체제로부터 시스템 자원을 할당받는다 했다. 이때 운영체제는 프로세스마다 각각 독립된 메모리 영역을, code/data/heap/stack의 형식으로 할당해준다.
    각각 독립된 메모리 영역을 할당해주므로 다른 프로세스의 변수나 자료에 접근할 수 없다.

    이와 다르게 스레드는 메모리를 공유할 수 있다. stack 부분만 따로 할당받고 나머지(code,data,heap)은 공유한다. 
    이러한 메모리 공유의 이유는, 운영체제 관점에서는 프로세스가 최소 단위이고 이 프로세스만 관리할 수 있는데, 각 스레드가 메모리를 각각 할당받아 사용해버리면 관리가 안되기 때문이다(정확한 답은 아닐거같다. 좀 더 찾아보자.)

    정리하자면, 운영체제가 프로세스에게 code/data/heap/stack 메모리 영역을 할당해주고 최소 단위로 삼는다. 
    스레드는 프로세스 내에서 stack을 제외한 다른 메모리 영역을 공유한다. 다만 동기화 문제를 신경써야만 한다.
  </div>
</details>

2. 메모리 구조
<details>
  <summary>답변보기 ▾</summary>
  <div markdown="1">
    코드, 데이터, 스택, 힙으로 구분된다. 프로그램이 메모리에 올라가게 되면 운영체제로부터 해당 메모리 영역을 할당받는다. 
    코드 영역에는 소스코드가 들어가고
    데이터 영역에는 전역변수, 정적변수 등이 저장된다. 프로그램이 끝날 때 까지 메모리에 남아있다. 초기화된 변수 영역과 초기화 안된 변수영역(BSS)로 나뉜다.
    힙 영역에는 동적으로 할당할 변수들이 저장되는 공간. 오브젝트 들이 이 곳에 저장된다. 사용자에 의해 메모리 공간이 동적으로 할당된다. 
    스택 영역에는 함수 호출할 때 지역변수, 매개변수 등이 저장되는 곳이다. 함수가 종료되면 해당 함수에 할당된 변수들도 메모리에서 해제한다.

  </div>
</details>

3. CPU 스케쥴러
<details>
  <summary>답변보기 ▾</summary>
  <div markdown="1">
    레디큐에 있는 프로세스에 대해 CPU 할당하는 방법, 혹은 스케쥴링을 CPU 스케쥴러가 관리.

    비선점형 스케쥴링
    - FCFS(First Come First Serve)
      - 먼저 CPU를 요청하는 프로세스부터 처리
    - SJF(Shortest Job First)
      - CPU 사용하는 시간 적은걸 먼저 실행
      - 근데 사용시간 긴 프로세스는 기아상태 빠질 수 있음

    선점형 스케쥴링
    - SRT(Shortes Remaining Time)
      - 최단 잔여시간을 우선으로 하는 스케쥴링
      - 진행중인 프로세스가 있어도 최단 잔여시간인 프로세스를 위해 슬립 시키고 짧은 프로세스를 할당
    - 라운드로빈
      - 모든 프로세스가 같은 우선순위를 가지고 time slice를 기반으로 스케쥴링
      - 라운드로빈 레디큐에서 타임 슬라이스따라 프로세스 돌려가며 실행하는데 만약 2번프로세스 실행 시간이 남았다면 정해진 타임동안 실행 후 다시 큐의 뒷부분에 넣는다.
      - 타임퀀텀(타임슬라이스) 심하게 크면 FCFS랑 별다를 거 없고, 너무 짧게 가져가면 컨텍스트 스위칭 잦아서 오버헤드 발생(비효율적)
  </div>
</details>


4. 가상 메모리
<details>
  <summary>답변보기 ▾</summary>
  <div markdown="1">
    실제 각 프로세스마다 충분한 메모리 할당하기에는 메모리 크기 한계가 있음.
    그래서 실행에 필요한 부분만 메모리에 올림.
  </div>
</details>

5. 데드락
<details>
  <summary>답변보기 ▾</summary>
  <div markdown="1">
    둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황
    데드락 발생 조건
    - 상호배제: 자원은 한 번에 한 프로세스만이 사용할 수 있어야 함
    - 정유대기: 최소한 하나의 자원을 점유하고 있으면서 동시에 다른 프로세스에 할당된 자원을 대기하는 프로세스가 있어야 한다
    - 비선점: 다른 프로세스에 할당된 자원은 사용이 끝날 때 까지 강제로 뺏을 수 없다
    - 순환대기: 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있다
  </div>
</details>








